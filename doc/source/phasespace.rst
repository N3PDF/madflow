.. _phasespace-label:

Phase-Space
===========

Matrix Element files generated by the ``madflow`` :ref:`script <usage-label>`
need an input phase-space in order to provide results.

.. code-block:: bash

  madflow --madgraph_process "g g > t t~" -o gg_to_ttb --dry_run


The previous line will generate the relevant python files inside the ``gg_to_ttb`` directory,
among them ``matrix_1_gg_ttx`` which includes the matrix element ``Matrix_1_gg_ttx``.

The matrix element accepts phase space points with shape ``(n_events, n_particles, 4)`` and will
return as many weights as events are passed to it.

.. code-block:: python

  import numpy as np
  from matrix_1_gg_ttx import Matrix_1_gg_ttx

  # Instantiate the matrix element
  matrix = Matrix_1_gg_ttx()
  # Create a valid (fake) phase space point
  p_raw = np.array([ [3500, 0, 0, 3500], [3500, 0, 0, -3500] ]*2)
  p = p_raw.reshape(1, 4, 4)
  # Call the matrix element with the right masses and couplings
  me_wgt = matrix.smatrix(p, 173.0, 1.5, [-1.21 + 0j], [-1.21j])


Phase-Space generator 
----------------------

For convenience, ``madflow`` offers a :py:class:`PhaseSpaceGenerator <madflow.phasespace.PhaseSpaceGenerator>` class
which can generate phase space points using different algorithms (for now only RAMBO).

In order to instantiate a phase-space object the number of particles, the center of mass energies and the
mass of the final state objects must be given.
Furthermore, it is possible to ask for the phase-space to be provided in the center of mass frame
(``com_output=True``) or in the laboratory frame (``com_output=False``).

The phase-space object also provides methods to apply cuts to the final state particles.

.. code-block:: python

  import numpy as np
  from madflow.phasespace import PhaseSpaceGenerator

  # Generate an instance of the phase space
  phasespace = PhaseSpaceGenerator(4, 7e3, [173.0, 173.0], com_output=False)

  # Register a cut for particle 3 (0-index) of pt > 10 GeV and pt < 520 GeV
  phasespace.register_cut("pt", particle=3, min_val=10, max_val=520)

  # Generate ten phase space points
  xrand = np.random.rand(10, (4-2)*4+2)
  all_ps, wts, x1, x2, idx = phasespace(xrand)

The return quantities are as follows:

``all_ps``: tensor of shape ``(nevents, nparticles, 4)``, phase space points
``wts``: tensor of shape ``(nevents,)`` weight of each event.
``x1`` and ``x2``: parton fraction of the incoming momenta
``idx``: index of the valid phase space points

Note that the number of output phase-space events provided might not be equal to the number of phase-space point requested
as not all events might pass the cuts.
The ``idx`` variable contain the corresponding index of the events that passed all cuts.
  

Provided Algorithms
-------------------

Different algorithms can be utilized using the keyword ``algorithm``:


Ramboflow
^^^^^^^^^

Vectorized form of the well known `RAMBO <https://www.sciencedirect.com/science/article/abs/pii/0010465586901190>`_ algorithm.
It is a plain phase-space that does not take into account the topology of the processes being integrated,
however it can provide valid phase-space points for any number of particles which make it suitable for debugging
and development.
